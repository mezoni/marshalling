import 'dart:io';

import 'package:path/path.dart' as _path;
import 'package:yaml/yaml.dart' as yaml;

// Experimental
void main(List<String> args) {
  if (args.length != 1) {
    print('Usage: yaml2podo.dart file.yaml');
    exit(-1);
  }

  var inputFileName = args[0];
  var inputFile = File(inputFileName);
  var data = inputFile.readAsStringSync();
  var source = yaml.loadYaml(data);
  var generator = PrototypingGenerator(source as Map);
  var lines = generator.generate();
  var dirName = _path.dirname(inputFileName);
  var outputFileName = _path.basenameWithoutExtension(inputFileName);
  outputFileName = _path.join(dirName, outputFileName + '.dart');
  var outputFile = File(outputFileName);
  outputFile.writeAsStringSync(lines.join('\n'));
}

class PrototypingGenerator {
  Map _source;

  Map<String, _TypeInfo> _classes;

  _TypeInfo _dynamicType;

  Map<String, _TypeInfo> _primitiveTypes;

  Map<String, _TypeInfo> _types;

  PrototypingGenerator(Map source) {
    if (source == null) {
      throw ArgumentError.notNull('source');
    }

    _source = source;
  }

  List<String> generate() {
    _reset();
    for (var key in _source.keys) {
      var name = key.toString();
      var class_ = _parseTypeName(name);
      if (class_.typeArgs.isNotEmpty) {
        throw StateError('Generic types are not supported: ${class_.typeArgs}');
      }

      if (_classes.containsKey(class_.fullName)) {
        throw StateError('Duplicate type name: ${class_.fullName}');
      }

      if (class_.kind != _TypeKind.object) {
        throw StateError('Unable to generate class: ${class_.fullName}');
      }

      _classes[class_.fullName] = class_;
      _parseProps(class_, _source[key] as Map);
    }

    for (var class_ in _classes.values) {
      for (var prop in class_.props.values) {
        var propType = prop.type;
        void walkTypes(_TypeInfo type) {
          if (_types.containsKey(type.fullName)) {
            return;
          }

          for (var typeArg in type.typeArgs) {
            walkTypes(typeArg);
          }

          switch (type.kind) {
            case _TypeKind.iterable:
            case _TypeKind.list:
            case _TypeKind.map:
              _types[type.fullName] = type;
              break;
            default:
              break;
          }
        }

        switch (propType.kind) {
          case _TypeKind.bottom:
            break;
          case _TypeKind.iterable:
          case _TypeKind.list:
          case _TypeKind.map:
            walkTypes(propType);
            break;
          case _TypeKind.object:
            if (!_classes.containsKey(propType.fullName)) {
              throw StateError('Unknown property type: ${propType}');
            }

            break;
          case _TypeKind.primitive:
            break;
          default:
            throw StateError('Unsupported property type: ${propType}');
        }
      }
    }

    var accessors = Set<String>();
    var classes = _classes.values.toList();
    classes.sort((e1, e2) => e1.fullName.compareTo(e2.fullName));
    var lines = <String>[];
    lines.add('// Generated by tool.');
    lines.add('');
    lines.add('import \'package:marshalling/json_serializer.dart\';');
    lines.add('');
    lines.add('final json = JsonSerializer()');
    for (var class_ in classes) {
      var className = class_.fullName;
      lines.add('  ..addType(() => ${className}())');
      for (var prop in class_.props.values) {
        accessors.add(prop.name);
      }
    }

    for (var type in _types.values) {
      var typeName = type.fullName;
      var typeArgs = type.typeArgs;
      switch (type.kind) {
        case _TypeKind.iterable:
        case _TypeKind.list:
          var typeArg0 = typeArgs[0].fullName;
          lines.add(
              '  ..addIterableType<${typeName}, ${typeArg0}>(() => <${typeArg0}>[])');
          break;
        case _TypeKind.map:
          var typeArg0 = typeArgs[0].fullName;
          var typeArg1 = typeArgs[1].fullName;
          lines.add(
              '  ..addMapType<${typeName}, ${typeArg0}, ${typeArg1}>(() => <${typeArg0}, ${typeArg1}>{})');
          break;
        default:
          throw StateError('Internal error');
          break;
      }
    }

    for (var name in accessors.toList()..sort()) {
      lines.add(
          '  ..addAccessor(\'${name}\', (o) => o.${name}, (o, v) => o.${name} = v)');
    }

    for (var class_ in classes) {
      var className = class_.fullName;
      for (var prop in class_.props.values) {
        var propName = prop.name;
        var propType = prop.type.fullName;
        var alias = '';
        if (prop.alias != null) {
          alias = ', alias: \'${prop.alias}\'';
        }

        lines.add(
            '  ..addProperty<${className}, ${propType}>(\'${propName}\'${alias})');
      }
    }

    lines.last = lines.last + ';';
    lines.add('');
    for (var class_ in classes) {
      var className = class_.fullName;
      lines.add('class ${className} {');      
      for (var prop in class_.props.values) {
        var propTypeName = prop.type.fullName;
        var propName = prop.name;
        lines.add('  ${propTypeName} ${propName};');
      }

      lines.add('');
      lines.add('  ${className}();');
      lines.add('');
      lines.add('  factory ${className}.fromJson(Map map) {');
      lines.add('    return json.unmarshal<${className}>(map);');
      lines.add('  }');
      lines.add('');
      lines.add('  Map<String, dynamic> toJson() {');
      lines.add('    return json.marshal(this) as Map<String, dynamic>;');
      lines.add('  }');
      lines.add('}');
      lines.add('');
    }

    return lines;
  }

  _TypeInfo _createDynmaicType() {
    var result = _TypeInfo();
    result.fullName = "dynamic";
    result.kind = _TypeKind.bottom;
    result.simpleName = "dynamic";
    return result;
  }

  _TypeInfo _createPrimitiveType(String name) {
    var result = _TypeInfo();
    result.fullName = name;
    result.kind = _TypeKind.primitive;
    result.simpleName = name;
    return result;
  }

  void _parseProps(_TypeInfo type, Map data) {
    var props = <String, _PropInfo>{};
    for (var key in data.keys) {
      var nameParts = key.toString().trim().split('.');
      var name = nameParts[0].trim();
      String alias;
      if (nameParts.length > 1) {
        alias = nameParts[1].trim();
      }

      var typeName = data[key].toString();
      var type = _parseTypeName(typeName);
      var prop = _PropInfo();
      prop.alias = alias;
      prop.name = name;
      prop.type = type;
      props[name] = prop;
    }

    type.props.addAll(props);
  }

  _TypeInfo _parseTypeName(String name) {
    var fullName = name.trim();
    if (_primitiveTypes.containsKey(fullName)) {
      return _primitiveTypes[fullName];
    }

    if (fullName == 'dynamic') {
      return _dynamicType;
    }

    var result = _TypeInfo();
    var simpleName = fullName;
    var typeArgs = <_TypeInfo>[];
    var open = fullName.indexOf('<');
    var close = fullName.lastIndexOf('>');
    if (open > 0) {
      if (close == -1) {
        throw FormatException(name);
      }

      for (var arg in fullName.substring(open + 1, close).split(',')) {
        var typeArg = _parseTypeName(arg);
        typeArgs.add(typeArg);
      }

      simpleName = simpleName.substring(0, open);
    }

    void checkTypeArgsCount(List<_TypeInfo> args) {
      if (typeArgs.isEmpty) {
        typeArgs.addAll(args);
        return;
      }

      if (typeArgs.length != args.length) {
        throw StateError('Wrong number of type arguments: $fullName');
      }
    }

    _TypeKind kind;
    switch (simpleName) {
      case 'Iterable':
        checkTypeArgsCount([_dynamicType]);
        kind = _TypeKind.iterable;
        break;
      case 'List':
        checkTypeArgsCount([_dynamicType]);
        kind = _TypeKind.list;
        break;
      case 'Map':
        checkTypeArgsCount([_primitiveTypes['String'], _dynamicType]);
        kind = _TypeKind.map;
        break;
      default:
        if (typeArgs.isEmpty) {
          kind = _TypeKind.object;
        } else {
          kind = _TypeKind.unknown;
        }
    }

    result.fullName = fullName;
    result.kind = kind;
    result.simpleName = simpleName;
    result.typeArgs.addAll(typeArgs);
    return result;
  }

  void _reset() {
    _dynamicType = _createDynmaicType();
    _classes = {};
    _types = {};
    _primitiveTypes = {};
    var names = ['bool', 'DateTime', 'double', 'int', 'num', 'String'];
    for (var name in names) {
      _primitiveTypes[name] = _createPrimitiveType(name);
    }
  }
}

class _PropInfo {
  String alias;
  String name;
  _TypeInfo type;

  @override
  String toString() => '$type $name';
}

class _TypeInfo {
  String fullName;
  _TypeKind kind;
  Map<String, _PropInfo> props = {};
  String simpleName;
  List<_TypeInfo> typeArgs = [];

  @override
  String toString() => '$fullName';
}

enum _TypeKind { bottom, iterable, list, map, object, primitive, unknown }
