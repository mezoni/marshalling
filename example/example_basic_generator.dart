import 'dart:mirrors';

Future<void> main() async {
  var path = 'example_json_objects.dart';
  var uri = Uri.parse(path);
  var mirrors = currentMirrorSystem();
  var library = await mirrors.isolate.loadUri(uri);
  var imports = ['package:json_marshalling/json_marshalling.dart', path];
  var result = _generate(library, imports);
  print(result);
}

List<VariableMirror> _findProperties(ClassMirror clazz) {
  var result = <VariableMirror>[];
  for (var member in clazz.declarations.values) {
    if (member is VariableMirror) {
      if (!member.isPrivate) {
        result.add(member);
      }
    }
  }

  result.sort(
      (e1, e2) => e1.simpleName.toString().compareTo(e2.simpleName.toString()));
  return result;
}

String _generate(LibraryMirror library, List<String> imports) {
  throw UnimplementedError();
  var iterableType = reflectClass(Iterable).originalDeclaration;
  var listType = reflectClass(List).originalDeclaration;
  var mapType = reflectClass(Map).originalDeclaration;
  var lines = <String>[];
  lines.add('// Generated by tool');
  lines.add('');
  if (imports.isNotEmpty) {
    for (var element in imports) {
      lines.add('import \'$element\';');
    }

    lines.add('');
  }

  lines.add('final _json = JsonSerializer()');
  var accessors = <String>[];
  var classes = <ClassMirror>[];
  var properties = <VariableMirror>[];
  var types = <TypeMirror>[];
  for (var declaration in library.declarations.values) {
    if (declaration is ClassMirror) {
      if (declaration.typeVariables.isNotEmpty) {
        var name = _typeName(declaration);
        throw StateError('Generic classes are not supported: $name');
      }

      classes.add(declaration);
    }
  }

  lines.add('  // Classes');
  classes.sort((e1, e2) => e1.toString().compareTo(e2.toString()));
  for (var clazz in classes) {
    for (var property in _findProperties(clazz)) {
      properties.add(property);
      accessors.add(_symbolToString(property.simpleName));
    }

    var name = _typeName(clazz);
    lines.add('  ..addType(() => $name())');
  }

  lines.add('  // Types');
  for (var property in properties) {
    var propertyType = property.type;    
    if (propertyType.typeArguments.isNotEmpty) {
      var isIiterableType = propertyType.originalDeclaration == iterableType;
      var isListType = propertyType.originalDeclaration == listType;
      var isMapType = propertyType.originalDeclaration == mapType;
      if (isIiterableType) {
        //
      } else if (isListType) {
        //
      } else {
        var ownerName = _symbolToString(property.owner.simpleName);
        var name = _symbolToString(property.simpleName);
        var typeName = _typeName(property.type);
        var message =
            'Properties with generic types are not supported: ${typeName} ${ownerName}.${name}';
        throw StateError(message);
      }

      //
    }
  }

  lines.add('  // Accessors');
  accessors.sort();
  for (var element in Set.from(accessors)) {
    var name = element;
    lines.add(
        '  ..addAccessor(\'$name\', (o) => o.$name, (o, v) => o.$name = v)');
  }

  lines.add('  // Properties');
  for (var element in properties) {
    var name = _symbolToString(element.simpleName);
    var typeName = _typeName(element.type);
    var ownerName = _symbolToString(element.owner.simpleName);
    if (name == 'items') {
      print(element.type.simpleName);
    }

    lines.add('  ..addProperty<$ownerName, $typeName>(\'$name\')');
  }

  var result = lines.join('\n') + ';';
  return result;
}

String _symbolToString(Symbol symbol) {
  var result = symbol.toString();
  result = result.replaceFirst('Symbol("', '');
  result = result.replaceFirst('")', '');
  return result;
}

String _typeName(TypeMirror type) {
  var name = _symbolToString(type.simpleName);
  var parameters = <String>[];
  List<TypeMirror> types;
  if (type.isOriginalDeclaration) {
    types = type.typeVariables;
  } else {
    types = type.typeArguments;
  }

  for (var element in types) {
    var parameter = _typeName(element);
    parameters.add(parameter);
  }

  var result = name;
  if (parameters.isNotEmpty) {
    result = result + '<${parameters.join(', ')}>';
  }

  return result;
}
